Diff between [Route("")] and [HttpGet("")], for an instance:
    Route is used for method-nonspecific. Like exception handling and declaring the base path for all actions in the controller.
    Method-specific, like [HttpGet], obviously is only relevant for methods that GET shit. Eitherway, their end-result is the same.
    But are Attribute-based routing.

DTOs:
    Data Transfer Objects,
    By passing models from client to server, the preferred intermiedatry seems to *not* be the model itself.
    I.E: You may have an object that can contain 100 values, but only want to pass 2. DTOs are the ground-up objects that are custom-defined
         only contain these very limited fields, variables, and all. Probably to save on bandwidth or something.
         The downside to DTOs, is that there is a need to convert from BASE-OBJECT to DTO-OBJECT back and forth.

DataContext:
TODO:: add shit about datacontext.

To seed the DB with rows:
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Skill>().HasData(
                new Skill {id = 1, name = "fireball", damage = 15},
                new Skill {id = 2, name = "ice arrow", damage = 7},
                new Skill {id = 3, name = "lightning bolt", damage = 20},
                new Skill {id = 4, name = "earth lance", damage = 12}
            );
        }

AutoMapper:
 A library that allows convert one object to another, by automatically assigning the variable of class A to the variables of class B.
 Automapper requires the creation of AutoMapperProfile.cs file to manage its conversion profiles --  from Source classes, to a designated Target class. Such as: 
    CreateMap<SourceClass, TargetClass>();
Automapper can either create a new instance object from a source, existing instance,
Or Map an existing instance to an existing instance (update).
cmds:
    _mapper.Map<Character>(getCharacterDTO_object);     //convert existing getCharacterDTO_object to a new Character instance.
    _mapper.Map(getCharacterDTO_object, character_object);            //convert the existing getCharacterDTO_object into the existing character_object instance. I.E: Update character with getCharacter values!   

ServiceResponse:
    A generic class, 
        public class ServiceResponse<T> { public T? data...}
    that acts as a WRAPPER-OBJECT. data is any object to be transferred, but the ServiceResponse also reports for errors (String msgs), and operation success / failure. 

SQL relationships:
    One-to-One:
        a relationship where in a table, only *one* entry can be tied to a foreign-table. 
        A unique person has only 1 unique passport. Let's say the passport is linked to a unique person. If we'll try to link to the same person in another passport, we'll get an error.
        The table which links to another, is the 'dependent'.
        To achieve this in EF, we create in Person a Passport object and an int passportId. This makes Person the dependent. In Passport, we create a Person object.
        Migrate, etc, database update.


Tools:
    Dotnet ef
        ef (entity framework), this tool exists to aid in Migrations.
        Migrations -- basically, the data model can constantly change. Add, remove, etc. A Migration is moving the data-model into the database.
        the ef-tool exists to migrate the models to the database, and to aid in production by ensuring that the databases do not get deleted to fit the new data model.

        dotnet ef migrations <commands>
                             add <Name>

    From 0, 
    1. we go to appsettings.json -> add { "ConnectionStrings": { "DefaultConnection" : ... }}. This'll allow ef to connect to our sql-database.
    2. Then we want to create the DataContext object (public class DataContext : DbContext,  with a var that is defined as: DbSet<Object> <ObjectName>),
    This DataContext is like a profile for the Migrations.
    3. We then run (dotnet ef migrations add InitialCreate) to establish the migration of our model, dbSet<Character> (data model Character), to our SQL server.
    4. Then run dotnet ef database update, to "update the database to a specified migration".
    


Notes for skills:
0. skills relationship being many-to-many, outside of the 'skill' table that lists all skills, there's an extra table (CharacterSkills) to list the relationship of a character to many skills.
1. Instead of adding an interface for skill addition, this time we played around with Row Seeding. In the DataContext class, we overriden the function OnModelCreating, and seeded with
     modelBuilder.Entity<Skill>().HasData( ... )